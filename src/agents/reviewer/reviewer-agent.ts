import { IAgent, AgentType, IAgentRequest, IAgentResponse, IAgentState, AgentStatus, IAlert } from '../shared/agent.interface.js';
import { LLMProviderManager } from '../../llm/provider-manager.js';
import { ExtensionStateManager } from '../../state/extension-state-manager.js';
import * as vscode from 'vscode';

/**
 * ReviewerAgent is responsible for validating code generated by the CoderAgent,
 * identifying security risks, edge cases, and architectural non-compliance.
 */
export class ReviewerAgent implements IAgent {
    public readonly name: AgentType = 'reviewer';
    public readonly displayName: string = 'Reviewer Agent';
    public readonly icon: string = 'üõ°Ô∏è';

    private llmManager: LLMProviderManager | undefined;
    private status: AgentStatus = 'idle';
    private currentTask: string | undefined;

    constructor() { }

    public initialize(llmManager: LLMProviderManager): void {
        this.llmManager = llmManager;
    }

    public async execute(request: IAgentRequest): Promise<IAgentResponse> {
        if (!this.llmManager) {
            throw new Error('ReviewerAgent not initialized with LLMProviderManager');
        }

        this.updateState('thinking', 'Reviewing generated code for risks...');

        const systemPrompt = `You are the Reviewer Agent for AI-101. 
Your goal is to perform a rigorous security and quality review of the generated code.
Focus on:
1. Security Vulnerabilities (SQL injection, XSS, Command injection, hardcoded secrets).
2. Edge cases (null/undefined, error handling, boundary conditions).
3. Technical debt and performance issues.

EXPECTED OUTPUT FORMAT:
[STATUS]
PASS or FAIL
[RISKS]
List any identified risks or vulnerabilities.
[RECOMMENDATIONS]
List specific improvements or fixes.
[REASONING]
Briefly explain your overall assessment.`;

        const finalPrompt = `${systemPrompt}\n\nPROJECT CONTEXT:\n${request.context || 'No context provided'}\n\nCODE TO REVIEW:\n${request.prompt}`;

        try {
            const llmResponse = await this.llmManager.callLLM(this.name, finalPrompt, request.options);

            // Parse response
            const text = llmResponse.text;
            const statusMatch = text.match(/\[STATUS\]([\s\S]*?)\[RISKS\]/);
            const risksMatch = text.match(/\[RISKS\]([\s\S]*?)\[RECOMMENDATIONS\]/);
            const recsMatch = text.match(/\[RECOMMENDATIONS\]([\s\S]*?)\[REASONING\]/);
            const reasoningMatch = text.match(/\[REASONING\]([\s\S]*)/);

            const status = statusMatch ? statusMatch[1].trim() : 'PASS';
            const risks = risksMatch ? risksMatch[1].trim() : '';
            const recommendations = recsMatch ? recsMatch[1].trim() : '';
            const reasoning = reasoningMatch ? reasoningMatch[1].trim() : text;

            const isFail = status.toUpperCase().includes('FAIL') || risks.length > 20;
            this.updateState(isFail ? 'alert' : 'success', isFail ? 'Risks detected during review.' : 'Review complete, code looks good.');

            if (isFail) {
                const activeEditor = vscode.window.activeTextEditor;
                const anchorLine = activeEditor?.selection.active.line;

                const alert: IAlert = {
                    id: `review-${Date.now()}`,
                    agent: this.name,
                    severity: risks.toLowerCase().includes('critical') || risks.toLowerCase().includes('security') ? 'urgent' : 'warning',
                    message: risks.substring(0, 200),
                    anchorLine,
                    timestamp: Date.now()
                };
                ExtensionStateManager.getInstance().addAlert(alert);
            }

            const result = `Validation Status: ${status}\n\nRisks:\n${risks}\n\nRecommendations:\n${recommendations}`;

            return {
                result: result,
                reasoning: reasoning,
                confidence: 0.95
            };
        } catch (error: any) {
            this.updateState('alert', `Error during review: ${error.message}`);
            throw error;
        }
    }

    public getState(): IAgentState {
        return {
            status: this.status,
            currentTask: this.currentTask,
            lastUpdate: Date.now()
        };
    }

    private updateState(status: AgentStatus, task?: string): void {
        this.status = status;
        this.currentTask = task;
    }
}
