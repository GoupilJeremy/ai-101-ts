import { IAgent, AgentType, IAgentRequest, IAgentResponse, IAgentState, AgentStatus, IAlert } from '../shared/agent.interface.js';
import { LLMProviderManager } from '../../llm/provider-manager.js';
import { ExtensionStateManager } from '../../state/extension-state-manager.js';
import { ModeManager } from '../../modes/mode-manager.js';
import { AgentMode } from '../../modes/mode-types.js';
import { EdgeCasePromptBuilder } from './libs/edge-case-prompt-builder.js';
import { SecurityPromptBuilder } from './libs/security-prompt-builder.js';
import { IReviewerResult, IEdgeCase } from './reviewer.interface.js';
import { PhasePromptBuilder } from '../shared/phase-prompt-builder.js';
import * as vscode from 'vscode';

/**
 * ReviewerAgent is responsible for validating code generated by the CoderAgent,
 * identifying security risks, edge cases, and architectural non-compliance.
 */
export class ReviewerAgent implements IAgent {
    public readonly name: AgentType = 'reviewer';
    public readonly displayName: string = 'Reviewer Agent';
    public readonly icon: string = 'üõ°Ô∏è';

    private llmManager: LLMProviderManager | undefined;
    private status: AgentStatus = 'idle';
    private currentTask: string | undefined;

    constructor() { }

    public initialize(llmManager: LLMProviderManager): void {
        this.llmManager = llmManager;
    }

    public async execute(request: IAgentRequest): Promise<IAgentResponse> {
        if (!this.llmManager) {
            throw new Error('ReviewerAgent not initialized with LLMProviderManager');
        }

        this.updateState('thinking', 'Reviewing generated code for risks...');

        const mode = ModeManager.getInstance().getCurrentMode();
        let modeInstructions = '';
        if (mode === AgentMode.Expert) {
            modeInstructions = `
[EXPERT MODE ACTIVE]
Provide in-depth security and quality analysis for experienced developers. Keep it concise and signal-focused.
- Reference specific OWASP Top 10 vulnerabilities
- Explicitly enumerate edge cases and security flaws
- Provide condensed, actionable insights`;
        }

        const edgeCaseCriteria = EdgeCasePromptBuilder.getCriteria();
        const securityCriteria = SecurityPromptBuilder.getCriteria();

        // Feature 6.9: Development Phase Adaptation
        let phaseInstructions = '';
        if (request.data && request.data.currentPhase) {
            phaseInstructions = PhasePromptBuilder.buildSystemPrompt(request.data.currentPhase);
        }

        const systemPrompt = `You are the Reviewer Agent for AI-101.
Your goal is to perform a rigorous security and quality review of the generated code.

${modeInstructions}

${edgeCaseCriteria}
${securityCriteria}
${phaseInstructions}

### JSON OUTPUT FORMAT

You must output the results in a strict Valid JSON format embedded within your response.
Include specific instances of risks found.

Expected JSON Structure:
\`\`\`json
{
  "status": "PASS" | "FAIL",
  "risks": "Summary string...",
  "recommendations": "Summary string...",
  "edgeCases": [
    {
      "id": "ec-1",
      "type": "null_undefined" | "async_error" | "boundary" | "input_validation" | "race_condition" | "ui_state" | "i18n",
      "description": "...",
      "fix": "...",
      "severity": "warning" | "critical",
      "lineAnchor": 0
    }
  ],
  "securityIssues": [
    {
      "id": "sec-1",
      "type": "sql_injection" | "xss" | "command_injection" | "hardcoded_secret" | "insecure_cryptography" | "csrf" | "auth_bypass",
      "description": "...",
      "Severity": "critical" | "urgent",
      "exploitScenario": "...",
      "secureFix": "...",
      "lineAnchor": 0
    }
  ]
}
\`\`\`

If no issues are found, return empty arrays.`;

        const finalPrompt = `${systemPrompt}\n\nPROJECT CONTEXT:\n${request.context || 'No context provided'}\n\nCODE TO REVIEW:\n${request.prompt}`;

        try {
            const llmResponse = await this.llmManager.callLLM(this.name, finalPrompt, request.options);
            const text = llmResponse.text;

            // Attempt to extract JSON
            let reviewerResult: IReviewerResult = {
                status: 'PASS',
                risks: '',
                recommendations: '',
                edgeCases: [],
                securityIssues: []
            };

            try {
                const jsonStart = text.indexOf('{');
                const jsonEnd = text.lastIndexOf('}');
                if (jsonStart !== -1 && jsonEnd !== -1) {
                    const jsonStr = text.substring(jsonStart, jsonEnd + 1);
                    const parsed = JSON.parse(jsonStr);
                    if (parsed.status) {reviewerResult = parsed;}
                } else {
                    const statusMatch = text.match(/\[STATUS\]([\s\S]*?)\[RISKS\]/);
                    if (statusMatch) {reviewerResult.status = statusMatch[1].trim() as any;}
                }
            } catch (e) {
                console.warn('Failed to parse Reviewer JSON:', e);
                reviewerResult.risks = text.substring(0, 500);
            }

            // Ensure arrays exist if parsing failed or partial
            if (!reviewerResult.edgeCases) {reviewerResult.edgeCases = [];}
            if (!reviewerResult.securityIssues) {reviewerResult.securityIssues = [];}

            const isFail = reviewerResult.status === 'FAIL' ||
                reviewerResult.risks.length > 20 ||
                reviewerResult.edgeCases.length > 0 ||
                reviewerResult.securityIssues.length > 0;

            this.updateState(isFail ? 'alert' : 'success', isFail ? 'Risks/Security Issues detected.' : 'Review complete, code looks good.');

            const activeEditor = vscode.window.activeTextEditor;
            // Process risks/alerts
            if (isFail) {
                const anchorLine = activeEditor?.selection.active.line;

                // Main Review Alert
                if (reviewerResult.risks) {
                    this.createAlert(reviewerResult.risks, 'warning', anchorLine);
                }

                // Process Edge Cases
                for (const ec of reviewerResult.edgeCases) {
                    const msg = `Edge Case (${ec.type}): ${ec.description}\nFix: ${ec.fix}`;
                    this.createAlert(msg, ec.severity || 'warning', ec.lineAnchor || anchorLine);
                }

                // Process Security Issues
                for (const sec of reviewerResult.securityIssues) {
                    const msg = `SECURITY (${sec.type}): ${sec.description}\nExploit: ${sec.exploitScenario}\nFix: ${sec.secureFix}`;
                    this.createAlert(msg, sec.severity || 'critical', sec.lineAnchor || anchorLine, sec);
                }
            }

            const resultStr = `Validation Status: ${reviewerResult.status}\n\nRisks:\n${reviewerResult.risks}\n\nRecommendations:\n${reviewerResult.recommendations}`;

            return {
                result: resultStr,
                reasoning: text, // Keep full text as reasoning
                confidence: 0.95,
                data: reviewerResult
            };
        } catch (error: any) {
            this.updateState('alert', `Error during review: ${error.message}`);
            throw error;
        }
    }

    private createAlert(message: string, severity: 'info' | 'warning' | 'critical' | 'urgent', anchorLine?: number, data?: any) {
        let alertMessage = message.substring(0, 200);
        const currentMode = ModeManager.getInstance().getCurrentMode();
        if (currentMode === AgentMode.Learning && !data) {
            alertMessage += '\n\nüí° Learn why this is a risk: https://owasp.org/www-project-top-ten/';
        } else if (currentMode === AgentMode.Expert) {
            alertMessage = message.substring(0, 150);
        }

        const alert: IAlert = {
            id: `review-${Date.now()}-${Math.random()}`,
            agent: this.name,
            severity: severity,
            message: alertMessage,
            anchorLine,
            timestamp: Date.now(),
            data
        };
        ExtensionStateManager.getInstance().addAlert(alert);
    }

    public getState(): IAgentState {
        return {
            status: this.status,
            currentTask: this.currentTask,
            lastUpdate: Date.now()
        };
    }

    private updateState(status: AgentStatus, task?: string): void {
        this.status = status;
        this.currentTask = task;
    }
}
