import { IAgent, AgentType, IAgentRequest, IAgentResponse, IAgentState, AgentStatus, IAlert } from '../shared/agent.interface.js';
import { LLMProviderManager } from '../../llm/provider-manager.js';
import { ExtensionStateManager } from '../../state/extension-state-manager.js';
import { ModeManager } from '../../modes/mode-manager.js';
import { AgentMode } from '../../modes/mode-types.js';
import { EdgeCasePromptBuilder } from './libs/edge-case-prompt-builder.js';
import { IReviewerResult, IEdgeCase } from './reviewer.interface.js';
import * as vscode from 'vscode';

/**
 * ReviewerAgent is responsible for validating code generated by the CoderAgent,
 * identifying security risks, edge cases, and architectural non-compliance.
 */
export class ReviewerAgent implements IAgent {
    public readonly name: AgentType = 'reviewer';
    public readonly displayName: string = 'Reviewer Agent';
    public readonly icon: string = 'üõ°Ô∏è';

    private llmManager: LLMProviderManager | undefined;
    private status: AgentStatus = 'idle';
    private currentTask: string | undefined;

    constructor() { }

    public initialize(llmManager: LLMProviderManager): void {
        this.llmManager = llmManager;
    }

    public async execute(request: IAgentRequest): Promise<IAgentResponse> {
        if (!this.llmManager) {
            throw new Error('ReviewerAgent not initialized with LLMProviderManager');
        }

        this.updateState('thinking', 'Reviewing generated code for risks...');

        const mode = ModeManager.getInstance().getCurrentMode();
        let modeInstructions = '';
        if (mode === AgentMode.Expert) {
            modeInstructions = `
[EXPERT MODE ACTIVE]
Provide in-depth security and quality analysis for experienced developers. Keep it concise and signal-focused.

Enhanced focus areas:
- Reference specific OWASP Top 10 vulnerabilities when applicable
- Explicitly enumerate edge cases with specific handling recommendations
- Analyze time/space complexity implications of suggested fixes
- Flag architectural anti-patterns and long-term maintainability concerns
- Provide condensed, actionable insights - no hand-holding explanations`;
        }

        const edgeCaseSystemPrompt = EdgeCasePromptBuilder.buildSystemPrompt();

        const systemPrompt = `You are the Reviewer Agent for AI-101.
Your goal is to perform a rigorous security and quality review of the generated code.
Focus on:
1. Security Vulnerabilities (SQL injection, XSS, Command injection, hardcoded secrets).
2. Edge cases (null/undefined, error handling, boundary conditions).
3. Technical debt and performance issues.
${modeInstructions}

${edgeCaseSystemPrompt}

Your response must be VALID JSON. Do not include conversational text outside the JSON block if possible.`;

        const finalPrompt = `${systemPrompt}\n\nPROJECT CONTEXT:\n${request.context || 'No context provided'}\n\nCODE TO REVIEW:\n${request.prompt}`;

        try {
            const llmResponse = await this.llmManager.callLLM(this.name, finalPrompt, request.options);
            const text = llmResponse.text;

            // Attempt to extract JSON
            let reviewerResult: IReviewerResult = {
                status: 'PASS',
                risks: '',
                recommendations: '',
                edgeCases: []
            };

            try {
                // Find JSON block start/end if embedded
                const jsonStart = text.indexOf('{');
                const jsonEnd = text.lastIndexOf('}');
                if (jsonStart !== -1 && jsonEnd !== -1) {
                    const jsonStr = text.substring(jsonStart, jsonEnd + 1);
                    const parsed = JSON.parse(jsonStr);
                    if (parsed.status) reviewerResult = parsed;
                } else {
                    // Fallback to legacy parsing if JSON fails or not found (for robustness)
                    const statusMatch = text.match(/\[STATUS\]([\s\S]*?)\[RISKS\]/);
                    if (statusMatch) reviewerResult.status = statusMatch[1].trim() as any;
                    // ... other legacy matches could go here, but focusing on JSON path
                }
            } catch (e) {
                console.warn('Failed to parse Reviewer JSON:', e);
                // Fallback: treat whole text as reasoning/risks
                reviewerResult.risks = text.substring(0, 500);
            }

            const isFail = reviewerResult.status === 'FAIL' || reviewerResult.risks.length > 20 || (reviewerResult.edgeCases && reviewerResult.edgeCases.length > 0);

            this.updateState(isFail ? 'alert' : 'success', isFail ? 'Risks/Edge Cases detected.' : 'Review complete, code looks good.');

            const activeEditor = vscode.window.activeTextEditor;
            // Process risks/alerts
            if (isFail) {
                const anchorLine = activeEditor?.selection.active.line;

                // Main Review Alert
                if (reviewerResult.risks) {
                    this.createAlert(reviewerResult.risks, 'warning', anchorLine);
                }

                // Process Edge Cases
                if (reviewerResult.edgeCases) {
                    for (const ec of reviewerResult.edgeCases) {
                        const msg = `Edge Case (${ec.type}): ${ec.description}\nFix: ${ec.fix}`;
                        this.createAlert(msg, ec.severity || 'warning', ec.lineAnchor || anchorLine);
                    }
                }
            }

            const resultStr = `Validation Status: ${reviewerResult.status}\n\nRisks:\n${reviewerResult.risks}\n\nRecommendations:\n${reviewerResult.recommendations}`;

            return {
                result: resultStr,
                reasoning: text, // Keep full text as reasoning
                confidence: 0.95,
                data: reviewerResult
            };
        } catch (error: any) {
            this.updateState('alert', `Error during review: ${error.message}`);
            throw error;
        }
    }

    private createAlert(message: string, severity: 'info' | 'warning' | 'critical' | 'urgent', anchorLine?: number, data?: any) {
        let alertMessage = message.substring(0, 200);
        const currentMode = ModeManager.getInstance().getCurrentMode();
        if (currentMode === AgentMode.Learning && !data) {
            alertMessage += '\n\nüí° Learn why this is a risk: https://owasp.org/www-project-top-ten/';
        } else if (currentMode === AgentMode.Expert) {
            alertMessage = message.substring(0, 150);
        }

        const alert: IAlert = {
            id: `review-${Date.now()}-${Math.random()}`,
            agent: this.name,
            severity: severity,
            message: alertMessage,
            anchorLine,
            timestamp: Date.now(),
            data
        };
        ExtensionStateManager.getInstance().addAlert(alert);
    }

    public getState(): IAgentState {
        return {
            status: this.status,
            currentTask: this.currentTask,
            lastUpdate: Date.now()
        };
    }

    private updateState(status: AgentStatus, task?: string): void {
        this.status = status;
        this.currentTask = task;
    }
}
